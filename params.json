{"name":"Sympler","tagline":"SYMPLER: SYMbolic ParticLE simulatoR","body":"Copyright 2002-2013, David Kauzlaric and other authors listed in the [AUTHORS](https://github.com/kauzlari/sympler/blob/master/AUTHORS) file.  \r\nThis program comes with ABSOLUTELY NO WARRANTY; for details see the [LICENSE](https://github.com/kauzlari/sympler/blob/master/LICENSE) file.  \r\nThis is free software, and you are welcome to redistribute it under certain conditions; for details see the [LICENSE](https://github.com/kauzlari/sympler/blob/master/LICENSE) file.\r\n\r\nPlease cite the publications in the [PUBLICATIONS](https://github.com/kauzlari/sympler/blob/master/PUBLICATIONS) file.\r\n\r\nFunding:  \r\nby the DFG (Deutsche Forschungsgemeinschaft) in the framework of \r\n+ SFB499 TPA4\r\n+ Project KA 3482/2\r\n+ Projects LI 1831/1-1,2\r\n\r\n\r\n______________________________________________________________________\r\n# Field of application:\r\n\r\nThe need for a unified flexible and modular simulation tool allowing for the investigation of structural, thermodynamic, and dynamical properties of fluids and solids from microscopic over mesoscopic up to macroscopic time and length scales with suitable particle based simulation methods such as molecular dynamics, dissipative particle dynamics or smoothed particle hydrodynamics. The user should be enabled to define her/his own physical models without the need for recoding or code extensions.\r\n\r\n\r\n______________________________________________________________________\r\n# Main features of SYMPLER:\r\n\r\n+ Modular object oriented structure that is passed to the user level and allows to easily switch among different integration algorithms, particle interaction forces, boundary conditions, etc. \r\n+ Arbitrary number of particle-species for the simulation of complex multi-component systems \r\n+ Arbitrary number of additional user-defined degrees of freedom per particle-species \r\n+ Symbolic definition of runtime compiled mathematical expressions for particle interactions \r\n+ Import of CAD-geometries in the STL-format\r\n\r\n\r\n______________________________________________________________________\r\n# Compiling SYMPLER:\r\n\r\n## Required tools for configuration and compilation: \r\n\r\n+ the GNU autotools (aclocal, libtool, autoconf, automake, etc.)\r\n+ a C++ compiler such as GNU g++\r\n+ a C compiler such as GNU gcc\r\n\r\n\r\n## Required libraries: \r\n\r\nGNU scientific library (GSL), libxml2\r\n\r\n## Optional libraries: \r\n\r\n+ libsdl: For simple runtime visualisation with the modules MeterLive and MeterLiveColoured. If the library is installed it will usually be found by the autotools and the modules will be compiled.\r\n+ OpenMP: For partial but still quite inefficient shared memory parallelisation. Use the option -fopenmp during configuration (CXXFLAGS=\"... -fopenmp\").\r\n+ libtnt, libjama, libsuperlu: Use the options --with-tnt --with-superlu during configuration. This allows for: \r\n  * coupling of particles to a linear system of equations solver with module IntegratorLSE\r\n  * the module for velocity constraints VelConstraints\r\n  * the integrator IntegratorVelocityVerletPressure\r\n\r\n\r\n## Configuration and Compilation:\r\n\r\nAll the commands invoked in the following have there own documentation. Please refer to it for more information. It follows first a standard method working on standard Linux systems such as Ubuntu 12.04. Below you find special instructions for MacOS.\r\n\r\n### Configuration and Compilation for standard Linux-systems:\r\n\r\nAssuming your source-code directory is $SOURCE-DIR, the series of commands that usually works is:\r\n\r\n$ cd $SOURCE-DIR\r\n$ libtoolize --force\r\n$ aclocal\r\n$ autoconf\r\n$ automake --add-missing\r\n\r\nThen, assuming your build-directory is $BUILD-DIR (it might be the same or different to $SOURCE-DIR):\r\n\r\n$ cd $BUILD-DIR\r\n$ $SOURCE-DIR/configure [options] CXXFLAGS=\"[cxxflags]\"\r\n$ make -j[1 to roughly the number of available cores]\r\n\r\nAfter successful compilation the executable \"sympler\" will be created in the directory src/ \r\nUseful [cxxflags] are (for more see the g++ documentation):\r\n\r\n-O3: for optimised compilation with g++\r\n-fopenmp: For compilation with OpenMP parallelisation (currently still inefficient)\r\n\r\nand useful [options] are:\r\n\r\n--with-tnt: use tnt library and jama libraries\r\n--with-superlu: use superlu \r\n--enable-all-static: for a statically linked stand alone executable not requiring any dynamical linking of libraries (except the runtime compiled expressions of course). Unfortunately this option currently causes SYMPLER to crash very often. We have this bug on our list. Further bug reports on this issue are welcome. A bug-fix is even more welcome. \r\n\r\n\r\n### Configuration and Compilation for MacOS\r\n\r\nThe following instructions were last successfully tested with Mac OS 10.6.8 and have been provided by Oliver Gruenert and Andreas Greiner.  \r\n\r\nThe libxml2 library comes already preinstalled by Apple. The easiest way to get the two remaining ones is to use one of the packaging-systems for Mac OS.\r\n\r\nOne of the best packaging-systems is homebrew. You can grab it and get a how-to install from http://github.com/mxcl/homebrew. Two nice properties of homebrew are, that it is easy to install and very easy to UNINSTALL, meaning that your operating system will be the same as before, without any old header or binary files lying around. The best way (also mentioned on http://github.com/mxcl/homebrew) is to install it in /usr/local and then \r\n\r\n$ sudo chown -R `whoami` /usr/local\r\n\r\nAfter homebrew is installed, you are ready to install the GSL and the SDL library. To install GSL type\r\n\r\n$ brew install gsl \r\n\r\ninto your terminal. \r\nThen, to install SDL type\r\n \r\n$ brew install sdl \r\n\r\ninto your terminal. \r\n\r\nTry first to skip this paragraph because the next step is only necessary if you run into trouble with your already preinstalled command-line tool gm4 (a macro processor used by aclocal). Then you need to replace it with a newer version, since the old version which came from Apple was broken. This was the case for example in MacOS 10.6.2. You can grab the most recent version from http://ftp.gnu.org/gnu/m4/. Now drag the old gm4 tool in /usr/bin to a backup folder (for example your Desktop) and replace it with the newer version (you will be asked to enter your root password).\r\n\r\nNow you are ready to compile sympler! So grab the moldyn source code into a code directory (called $CODE-DIR here) and create a new build directory (called $BUILD-DIR here) into which you will compile. Then in your terminal:\r\n\r\n$ cd $CODE-DIR\r\n$ aclocal -I /usr/local/Cellar/gsl/1.13/share/aclocal -I /usr/local/Cellar/sdl/1.2.14/share/aclocal\r\n$ autoconf\r\n$ glibtoolize --force. \r\n$ automake --add-missing\r\n\r\n$ cd $BUILD-DIR\r\n$ $CODE-DIR/configure CXXFLAGS=\"-O3\" --disable-shared\r\n$ make -j[1 to roughly the number of available cores]\r\n\r\nAfter successful compilation the executable \"sympler\" will be created in the directory src/ \r\n\r\n\r\n### SYMPLER and Intel compilers:\r\n\r\nA few hints when using icc (the Intel C++ compiler) for SYMPLER:\r\n\r\n+ Set the environment variable LANG=C\r\n+ If using autoparallelization, set LD_LIBRARY_PATH to the lib directory of icc\r\n+ -ipo gave problems with linking\r\n\r\nOtherwise, compilation worked fine. A good configure invocation might look like (adapt the paths to your needs):\r\n\r\nexport LANG=C;\r\nexport LD_LIBRARY_PATH=/simstorage/software/intel/cpp11/lib/intel64;\r\n../sympler/configure CXX=/simstorage/software/intel/cpp11/bin/intel64/icc \\\r\nCC=/simstorage/software/intel/cpp11/bin/intel64/icc LDFLAGS='-lstdc++ -lz' \\\r\nCXXFLAGS=\"-O3 -ip -parallel -funroll-loops -complex-limited-range \\\r\n-IPF-fma -IPF-fltacc -IPF-fp-relaxed -fp-model=fast -no-debug -xSSE4.1 \\\r\n-mcmodel=medium -falign-functions -opt-calloc -unroll-aggressive\" \r\n\r\n\r\n______________________________________________________________________\r\n# Running SYMPLER\r\n\r\nA static executable will work, if your glibc is roughly the same as the one, which was used for compilation. Additionally executables are specific to 32 and 64 bit platforms, respectively. The modules MeterLive and MeterLiveColoured are not activated in a static version. Alternatively you can use a dynamically linked version.\r\n\r\nA dynamic executable needs at least the following libraries installed:\r\n\r\n+ gsl (GNU scientific library)\r\n+ libxml2 (for parsing the input files)\r\n\r\n## Starting the executables\r\n\r\nAssuming you have an executable with name sympler in the directory $BUILD-DIR, just type\r\n\r\n$ $BUILD-DIR/sympler\r\n\r\nand you will be told the further options you may try in order to really get s.th. useful out of the code. For example\r\n\r\n$ $BUILD-DIR/sympler --help \r\n\r\ngives a general help text.\r\n\r\n$ $BUILD-DIR/sympler --help all\r\n\r\nlists the help text for all available modules\r\n\r\n$ $BUILD-DIR/sympler --help [UNKNOWN]\r\n\r\ngives you a list of all groups of modules you may request help for if [UNKNOWN] is an argument that sympler does not understand. For example you may get help for the Integrators with \r\n\r\n$ $BUILD-DIR/sympler --help Integrators\r\n\r\nTo really start a simulation type\r\n\r\n$ $BUILD-DIR/sympler [INPUT-FILE]\r\n\r\nwhere [INPUT-FILE] is an input file in xml-format.\r\n\r\n\r\n## Input files\r\n\r\nThe code has a modular structure. This is reflected in the input files by using the XML-format (for further information on XML see: http://www.w3schools.com/xml/default.asp). A quick glance at the input files and the online-help text of the executable should be enough to understand how it works. All modules and their attributes are described in the online-help. A bit of definition: The XML-expression <ModuleName attributeName = \"value\" /> shows you the difference between a module name, an attribute name and the value assigned to the latter. Compare this with the example given below. If you play around with parameters, be aware of possible simulation instabilities due to a timestep being to large for your chosen parameters. In this case you will obtain some message that a particle flew to far. The timestep can be modified in the module <Controller> with the attribute dt. The number of timesteps can be changed with the attribute timesteps. All quantities have to be given in units of your choice for instance in such a way that the Boltzmann constant may be set to 1. All simulations are 3D. Quasi-2D-simulations can be performed by applying periodic boundary conditions. Real 2D simulations can be performed by enforcing interactions to happen only in 2D.  \r\n\r\nHere is a small example. The newest version of SYMPLER might complain because some modules or attributes are out-dated, but the general idea should become clear:\r\n\r\n    <Simulation  \r\n        simName=\"MDPD simulation\"  \r\n        inputFromResults=\"yes\">  \r\n        <Square\r\n                cutoff=\"1\"\r\n                name=\"L1\" />\r\n        <Square\r\n                cutoff=\"0.75\"\r\n                name=\"L075\" />\r\n        <Controller\r\n                timesteps=\"100000\"\r\n                statusEvery=\"10\"\r\n                dt=\"0.001\">\r\n                <IntegratorVelocityVerlet\r\n                        species=\"H\" />\r\n        </Controller>\r\n        <ValCalculatorRho\r\n                symbol=\"n\"\r\n                weightingFunction=\"L1\"\r\n                species1=\"H\"\r\n                species2=\"H\"\r\n                selfContribution=\"false\"/>\r\n    <!-- Fluid-fluid, attractive -->\r\n        <FPairVels\r\n                species1=\"H\"\r\n                species2=\"H\"\r\n                pairFactor=\"-1/4.7746*[rij]/rij*750\"\r\n                weightingFunction=\"L1\" />\r\n    <!-- Fluid-fluid, repulsive -->\r\n        <FPairVels\r\n                species1=\"H\"\r\n                species2=\"H\"\r\n                pairFactor=\"3.14159265*0.75^4/15*(ni+nj)*[rij]/rij*40\"\r\n                weightingFunction=\"L075\" />\r\n        <ThermostatPetersIso\r\n                temperature = \"15\"\r\n                dissipation = \"5\"\r\n                species1 = \"H\"\r\n                species2 = \"H\"\r\n                weightingFunction = \"L1\" />\r\n        <Phase>\r\n                <LinkedListCreator/>\r\n                <BoundaryCuboid\r\n                        boxX=\"32\"\r\n                        boxY=\"32\"\r\n                        boxZ=\"32\"\r\n                        periodicX=\"yes\"\r\n                        periodicY=\"yes\"\r\n                        periodicZ=\"no\">\r\n                        <ReflectorThermalize\r\n                                temperature=\"15\"\r\n                                oneHit=\"true\"/>\r\n                        <ParticleCreatorStatic\r\n                                density=\"20\"\r\n                                species=\"H\"\r\n                                corner1 = \"(10,10,18)\"\r\n                                corner2 = \"(22,22,6)\"\r\n                                temperature = \"5\"\r\n                                ellipsoid = \"true\" />\r\n                </BoundaryCuboid>\r\n        </Phase>\r\n        <MeterPosVel\r\n                measureEvery=\"1000\"\r\n                species=\"H\">\r\n                <OutputVTK\r\n                fileName=\"results/posvel_prepare.vtk\"\r\n                format=\"ascii\"></OutputVTK>\r\n        </MeterPosVel>\r\n        <GridAveragerStructured\r\n                avgOver=\"50\"\r\n                measureEvery=\"1000\"\r\n                nX=\"16\" nY=\"16\" nZ=\"16\">\r\n                <Pressure species=\"H\"/>\r\n                <OutputFile\r\n                        fileName=\"results/gas_pressure.dat\"\r\n                        multipleFiles=\"yes\"\r\n                        columns = \"H_pressure_mean\" />\r\n        </GridAveragerStructured>\r\n    </Simulation>\r\n\r\n\r\nBesides reading the help text, another way to quickly find out which attributes are allowed for a specific module, is to type some non-sense which most likely does not correspond to any attribute.\r\n\r\n\r\n## Runtime compiled expressions\r\n\r\nIn the example file you see some of them. For example \"...(ni+nj)*[rij]/rij*40 where 'n' is a user defined scalar symbol, [rij] is the distance vector [ri]-[rj] for particle pair (i,j) and 'rij' is its absolute value. Single indices 'i', 'j' denote a particle property while double indices 'ij' denote the property of the pair of particles. Type\r\n\r\n$ $BUILD-DIR/sympler --help expressions\r\n\r\nfor a complete overview of possible elements of runtime compiled expressions. Help for the two module-groups Forces and Symbols that use runtime-compiled expressions the most you can get with\r\n\r\n$ $BUILD-DIR/sympler --help Forces\r\n$ $BUILD-DIR/sympler --help Symbols\r\n\r\nFurther check the PUBLICATIONS file for publications explaining further details.\r\n\r\n\r\n______________________________________________________________________\r\n# Postprocessing\r\n\r\nSYMPLER produces output in various ASCII and binary formats, for example VTK, simple column data, or binary arrays of data. First of all you need Meters in your input file. Check\r\n\r\n$ $BUILD-DIR/sympler --help Meters\r\n\r\nIn the above example we have two Meters, namely MeterPosVel and GridAveragerStructured. The thing is that a Meter itself usually does not create any output. It just collects data. GridAveragerStructured is even lazier and lets GridMeters do the work. Check\r\n\r\n$ $BUILD-DIR/sympler --help GridMeters\r\n\r\nGridMeters are also Meters. Hence they also collect data and nothing else. For output you have to attach PostProcessors to the Meters. In the aexample above you can find two of them: OutputVTK and OutputFile. Check\r\n\r\n$ $BUILD-DIR/sympler --help Postprocessors\r\n","google":"sympler","note":"Don't delete this file! It's used internally to help with page regeneration."}